# Седмица 6 - Класове и обекти: Конструктори, деструктори и изключения

Този проект разширява системата за управление на герой от играта Elder Thing, добавяйки клас Enemy с динамично управлявана система от атаки.

## Структура на проекта

Проектът включва следните файлове:
- `enemy.hpp` - декларация на класа Enemy
- `enemy.cpp` - имплементация на методите за класа Enemy
- `test_enemy.hpp` - тестове за класа Enemy
- `main.cpp` - главна програма с меню за избор на тестове

## Клас Enemy

Класът `Enemy` съдържа следните характеристики:

### Член данни
- `name` - динамично алокиран масив от символи (име на врага)
- `hp` - текущи точки живот
- `maxHp` - максимални точки живот
- `attackPower` - основна сила на атаката

### Методи
- Конструктори:
  - Конструктор по подразбиране
  - Конструктор с параметри
  - Копиращ конструктор
- Деструктор
- Операции:
  - Оператор за присвояване
- Игрови механики:
  - Получаване на щети
  - Атакуване на играча
- Методи за извеждане на информация
--------

<details><summary><b>Сериозно, но интересно усложняване</b></summary>
<pre>
Добавете:

### Член данни
- `attackPatterns` - динамично алокиран масив от модели на атаки
- `attackPatternCount` - брой модели на атаки
- `currentAttackIndex` - индекс на текущата използвана атака
- `cooldownRemaining` - оставащо време за презареждане на атаката

### Вложени типове/Изцяло нов външен клас
- `struct AttackPattern` - структура, която описва модел на атака

### Методи
- Управление на атаките:
  - `addAttackPattern` - добавяне на нов модел на атака
  - `linkAttacks` - създаване на връзки между атаки с вероятности
  - `resetAttackCooldown` - нулиране на времето за презареждане
  - `selectNextAttack` - избор на следваща атака въз основа на вероятностите

## Система за модели на атаки

Системата за модели на атаки позволява:

1. **Динамично добавяне на атаки** - врагът може да има различен брой атаки, които се добавят по време на изпълнение

2. **Верижни атаки** - всяка атака може да има вероятностни връзки към следващи атаки, което позволява създаването на сложни комбинации

3. **Вероятностен избор** - следващата атака се избира на базата на вероятности, зададени за всяка връзка

4. **Система за презареждане (cooldown)** - всяка атака има време за презареждане, което ограничава използването й

### Структура на AttackPattern

- `name` - име на атаката (динамично алокиран масив от символи)
- `damage` - нанесени щети
- `cooldown` - време за презареждане
- `nextAttacks` - динамичен масив от указатели към следващи възможни атаки
- `nextAttackProbabilities` - вероятности за всяка следваща атака (0-100)
- `nextAttackCount` - брой на следващите възможни атаки
</pre>
</details>

--------

## Управление на паметта и изключения

Класът демонстрира правилното управление на динамично алоцирана памет, включително:

1. **Алокиране** - правилно заделяне на памет в конструкторите
2. **Освобождаване** - освобождаване на ресурси в деструктора
3. **Дълбоко копиране** - правилно копиране на динамични ресурси в копиращия конструктор и оператора за присвояване
4. **Обработка на изключения** - защита от невалидни операции

### Използване на изключения

В имплементацията се използват подходящи изключения за следните случаи:

1. **std::invalid_argument** - хвърля се при:
   - Невалидни параметри при създаване на враг (отрицателни HP или attackPower)
   - Невалидни параметри при създаване на атака (nullptr за име, отрицателни damage или cooldown)
   - Невалидни стойности за вероятност при свързване на атаки (извън диапазона 1-100)
   - Опит за задаване на отрицателна стойност за attackPower

2. **std::out_of_range** - хвърля се при:
   - Достъп до несъществуващ модел на атака
   - Опит за свързване на несъществуващи атаки
   - Използване на невалиден тип атака

## Тестване на проекта (не знам колко добре работи)

За компилиране и стартиране на тестовете:

```bash
g++ enemy.cpp player.cpp weapon.cpp main.cpp -o elder_thng_test
./elder_thng_test
```

# Допълнителна задача за упражнение

Да се дефинира клас `Bank Account`, определящ банкова сметка на клиент, със тояща се от: `име на клиент` (символен низ), `номер на банкова сметка` (символен низ) и `налична сума на клиент` (реално число). Името на клиента и номерът на банковата му сметка да се реализират в динамичната памет, като за всяка от тях се отдели толкова памет колкото е необходимо
Класът да притежава методи, чрез които може да: 
- създава банкова сметка;
- извежда на екрана банкова сметка;
- внася пари в банкова сметка;
- тегли пари от банкова сметка.

Да се дефинира главна функция, която създава две банкови сметки, извежда информацията в сметките, внася сума в една от сметките и тегли сума от другата сметка