# Седмица 11 - Виртуални методи и полиморфизъм в Elder Thing

Този проект разширява системата за управление на герой от играта Elder Thing, въвеждайки концепции за виртуални методи и полиморфизъм. Имплементацията позволява динамично изпълнение на методи в зависимост от реалния тип на обекта по време на изпълнение.

## Структура на проекта

Проектът включва следните файлове:
- `character.hpp` - декларация на базовия клас Character с виртуални методи
- `character.cpp` - имплементация на методите за базовия клас Character
- `astrologer.hpp` - декларация на класа Astrologer с презаписани виртуални методи
- `astrologer.cpp` - имплементация на методите за класа Astrologer
- `confessor.hpp` - декларация на класа Confessor с презаписани виртуални методи
- `confessor.cpp` - имплементация на методите за класа Confessor
- `spell.hpp` - модифицирана версия на класа Spell с виртуални методи
- `spell.cpp` - имплементация на методите за класа Spell
- `spell_types.hpp` - декларации на наследените класове за различни видове магии
- `spell_types.cpp` - имплементация на методите за различните видове магии
- `combat_manager.hpp` - нов клас за управление на битки с полиморфни обекти
- `combat_manager.cpp` - имплементация на класа за управление на битки
- `main.cpp` - главна програма, демонстрираща концепциите за полиморфизъм

## Виртуални методи и полиморфизъм

Проектът демонстрира следните концепции:

1. **Виртуални методи**:
   - Базовият клас `Character` дефинира виртуални методи за общо поведение
   - Дъщерните класове имплементират своя специфична версия на тези методи
   - Виртуалните методи позволяват динамично свързване (runtime binding)

2. **Виртуални деструктори**:
   - Базовият клас `Character` има виртуален деструктор
   - Гарантира правилното освобождаване на ресурси при унищожаване на обект чрез указател към базов клас

3. **Полиморфизъм**:
   - Масив или колекция от указатели към базовия клас може да съдържа обекти от различни типове
   - Чрез указател към базов клас може да се извиква правилната версия на метод според реалния тип на обекта

4. **Работа с полиморфни обекти**:
   - Нов клас `CombatManager` демонстрира управление на битки между различни видове герои
   - Използва се dynamic_cast и typeid за идентифициране на реалния тип на обект

## Виртуален деструктор

Когато базовия клас бъде унищожен чрез указател, виртуалният деструктор гарантира, че първо ще бъде извикан деструкторът на най-вътрешния наследник, след което деструкторите на родителските класове. Това е критично за предотвратяване на изтичане на памет.

### Пример за виртуален деструктор
```cpp
class Character {
public:
    // Виртуален деструктор
    virtual ~Character() {
        // Освобождаване на общи ресурси
    }
    // ...
};
```

## Виртуални методи в Character

Следните методи са дефинирани като виртуални, за да могат дъщерните класове да ги презаписват:

### Виртуални методи
- `virtual void attack(Character* target)` - атака срещу друг герой
- `virtual void defend()` - защитна позиция
- `virtual void useSpecialAbility()` - използване на специална способност
- `virtual std::string getClassName() const` - връща името на класа
- `virtual int calculateDamage() const` - изчислява базовите щети
- `virtual bool canUseSpell(const Spell* spell) const` - проверява дали героят може да използва определен тип магия

### Имплементация в дъщерни класове
Всеки дъщерен клас (Astrologer, Confessor) имплементира тези методи според собствената си логика, което позволява различно поведение в зависимост от типа на героя.

## Клас CombatManager

Нов клас, който демонстрира използването на полиморфизъм:

### Член данни
- `characters` - масив от указатели към Character
- `characterCount` - брой герои в системата

### Методи
- `addCharacter(Character* character)` - добавя герой към системата
- `removeCharacter(Character* character)` - премахва герой от системата
- `executeCombatRound()` - изпълнява един рунд от битката
- `getCharacterByType(const std::type_info& type)` - връща герой от специфичен тип
- `displayBattleStatus()` - показва текущото състояние на всички герои

## Модификации в йерархията на магиите

Класът Spell също е модифициран с виртуални методи:

### Виртуални методи в Spell
- `virtual void cast(Character* caster, Character* target)` - прилагане на магията
- `virtual std::string getSpellType() const` - връща типа на магията
- `virtual int calculateEffectPower(const Character* caster) const` - изчислява силата на ефекта

### Имплементация в дъщерните класове
- `SorcerySpell` имплементира методите с фокус върху висока атака и бонус от интелигентност
- `IncantationSpell` имплементира методите с фокус върху балансирана атака и бонус от вяра

## Демонстрация в main.cpp

Програмата включва примери за:
- Създаване на обекти от различни класове герои
- Работа с указатели към базов клас, сочещи към обекти от различни типове
- Масив от указатели към базов клас, съдържащ разнородни обекти
- Динамично свързване на виртуални методи по време на изпълнение
- Използване на CombatManager за симулация на битка
- Използване на dynamic_cast за идентификация и typeinfo за проверка на типове

## Забележка за командата за визуализиране на виртуалните таблици

За да визуализирате виртуалните таблици на компилираните класове, може да използвате следната команда:

### Подробна визуализация в текстов файл
```bash
g++ -fdump-class-hierarchy character.cpp astrologer.cpp confessor.cpp spell.cpp spell_types.cpp main.cpp -o elder_thing
```
Тази команда ще създаде файлове с разширение `.class` за всеки клас, съдържащи подробна информация за виртуалните таблици.

### Опростена визуализация в терминала
```bash
g++ -fdump-lang-class character.cpp astrologer.cpp confessor.cpp spell.cpp spell_types.cpp main.cpp -o elder_thing
```
Тази команда ще покаже по-опростена информация за виртуалните таблици директно в терминала.

## Примерни разширения
- Добавяне на интерфейси (абстрактни класове) за дефиниране на общо поведение
- Имплементация на по-сложна полиморфна йерархия с повече видове герои
- Създаване на система за събития, където различни видове герои реагират по различен начин
- Добавяне на шаблони за дизайн, използващи полиморфизъм (като Strategy, Visitor или Observer)