# Седмица 12: Подготовка за тест

## Задача: Система за управление на библиотека

За тази задача ще реализирате опростена система за управление на библиотека, която демонстрира следните концепции:
- Семантика на собственост (move semantics, copy constructors и т.н.)
- Предефиниране на оператори (различни видове)
- Работа с двоични файлове
- Основно наследяване

### Изисквания

#### 1. Йерархия на класовете за медия
Създайте основна йерархия за библиотечни медии:

- Създайте базов клас `Media` със:
  - Частни полета за:
    - `char* title`
    - `unsigned int id` (веднъж създадено, не се променя)
    - `bool available`
    - `Collection* owner` (указател към съдържащата колекция)
  - Подходящи конструктори, копиращ конструктор, конструктор за преместване, деструктор
  - Методи `displayInfo()` за извеждане на основна информация за медията
  - Методи `setOwner(Collection* newOwner)` и `getOwner()` за работа с указателя към колекцията
  - Метод `calculateLateFee(unsigned int daysLate)` който връща 0.5 лева за всеки ден закъснение

- Създайте производни класове с различно поведение:
  - `Book` (наследява `Media` с допълнителни полета):
    - `char* author` (име на автор)
    - `char* genre` (жанр на книгата)
    - `unsigned int pages` (брой страници)
    - `bool hardcover` (дали е с твърди корици)
    - `estimateReadingTime()`, който връща приблизително време за четене (pages / 30) часа
    - Различно изчисление на таксата за закъснение: `calculateLateFee(unsigned int daysLate)` връща 0.7 лева на ден за книги с твърди корици и 0.5 лева за меки корици
  
  - `Journal` (наследява `Media` с допълнителни полета):
    - `char* publisher` (издател)
    - `unsigned int issue` (номер на изданието)
    - `unsigned int publicationYear` (година на публикуване)
    - `bool scientific` (дали е научно издание)
    - `isRelevant(unsigned int currentYear)`, който връща дали списанието е актуално (< 5 години)
    - Различно изчисление на таксата за закъснение: `calculateLateFee(unsigned int daysLate)` връща 1.0 лева на ден за научни списания и 0.3 лева за други списания

#### 2. Клас `Collection`
Реализирайте клас `Collection` за съхранение на масив от указатели към `Media`:

- Частни членове:
  - `Book** books`
  - `Journal** journals`
  - `size_t capacity`
  - `size_t size`
  - `char* name` (име на колекцията)

- Реализирайте следните методи:
  - Конструктори (по подразбиране, с капацитет и име)
  - Копиращ конструктор и оператор за копиране
  - Конструктор за преместване и оператор за преместващо присвояване
  - Деструктор
  - `add(Book* item)` - добавя медия към колекцията и задава колекцията като собственик на медията
  - `add(Journal* item)` - добавя медия към колекцията и задава колекцията като собственик на медията
  - `remove(unsigned int id)` - премахва медия от колекцията и премахва указателя към собственик
  - `calculateTotalLateFees(unsigned int daysLate)` - изчислява общите такси за закъснение за всички елементи
  (както и всякакви други необходими методи)

#### 3. Предефиниране на оператори
Реализирайте следните оператори:

За класовете `Media`:
- Оператор `==` за сравняване на две медии по id
- Оператори за потоци (`<<` и `>>`) за конзолен вход/изход

За класа `Collection`:
- Оператор `[]` (както константна, така и неконстантна версии) за достъп до медии по индекс
- Оператор `()`, който приема низ и връща първата медия със съвпадащо заглавие
- Оператор `bool` за проверка дали колекцията не е празна
- Оператор `!` за проверка дали колекцията е празна
- Префиксен и постфиксен оператор `++`, които увеличават ID на всички медии в колекцията

Извън всеки клас, реализирайте:
- Бинарен оператор `+` за обединяване на две колекции

#### 4. Работа с двоични файлове
Реализирайте методи за:
- `bool Collection::saveToFile(const char* filename)` - записва всички данни от колекцията в двоичен файл
- `bool Collection::loadFromFile(const char* filename)` - зарежда данни за колекцията от двоичен файл

### Ограничения
- НЕ използвайте никакви контейнери от стандартната библиотека (vector, string и т.н.)
- Реализирайте правилно управление на паметта (без изтичане на памет)
- Всички низоподобни данни трябва да използват масиви от символи с динамично заделяне на памет
- Осигурете правилна const-коректност
- Медийните обекти НЕ се притежават от колекцията, а имат само указател към нея

### Тестване
Създайте файл `main.cpp`, който:
1. Създава няколко книги и списания с различни характеристики
2. Добавя ги към колекции
3. Демонстрира специфичното поведение на различните типове медии (различно изчисление на такси, оценка на време за четене, проверка за актуалност)
4. Демонстрира връзката между медии и техните колекции-собственици
5. Демонстрира всички реализирани оператори
6. Записва колекцията в двоичен файл и я зарежда отново
7. Проверява дали заредените данни съвпадат с оригиналните