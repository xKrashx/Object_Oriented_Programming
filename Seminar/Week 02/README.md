<h1>Потоци и Файлове. Текстови и бинарни файлове.</h1>

Видове потоци:
- Потоци за вход (istream).
- Потоци за изход (ostream).

![enter image description here](https://i.ibb.co/VDdDSnM/potoci.gif)


<h3>Пример за работа с вход от конзолата - cin(обект от тип istream).</h3>

```c++
#include <iostream>

int main()
{
	int a, b;
	std::cin >> a >> b;
}
```

<h3>Пример за работа с поток за изход - cout(обект от тип ostream).</h3>

```c++
#include <iostream>

int main()
{
	int a = 10;
	int b = 12;
	int c = a + b;

	std::cout << a << " + " << b << " = " << c << std::endl;
}
```
	
<h3>Работа с поток за вход от файл(ifstream)</h3>

```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ifstream file("myFile.txt"); // Трябва да съществува такъв файл!!!

	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a, b;

	file >> a >> b;

	file.close();
}
```

<h3>Работа с поток за изход към файл(ofstream)</h3>
   
```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ofstream file("myFile.txt");

	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a = 3;
	int b = 10;

	file << a << " " << b << " " << a + b << std::endl;

	file.close();
}
```

- ifstream или istream - get указател, който реферира елемента, който ще се прочете при следващата входна операция. 
- ofstream или ostream - put указател, който реферира мястото, където ще се запише следващият елемент.

<h3>Позициониране във файл</h3>

- tellg() - Връща позицията на текущия символ в **потока за четене**
- tellp() - Връща позицията на текущия символ в **потока за писане**
- seekg(offset, direction) - Премества get-указателят на **потока за четене** с offset символа в посоката, която е посочена.
- seekg(streampos idx) - Премества get-указателят на **потока за четене** на позиция idx.
- seekp(offset, direction) - Премества put-указателят на **потока за писане** с offset символа в посоката, която е посочена.
- seekp(streampos idx) - Премества put-указателят на **потока за писане** на позиция idx.

-**offset**: целочислена стойност. Отместването от direction.
-**direction**: Може да заема следите стойности:

1. ios::beg - началото на файла.
2. ios::cur - текущата позиция във файла.
3. ios::end - края на файла.

<h3>Режими на работа</h3>

```c++
ifstream str("file.txt", <режим на работа>);
```

Режимът на работа е цяло число. 

| ios         | Ефект:                                                                                                                           |    |
|-------------|----------------------------------------------------------------------------------------------------------------------------------|----|
| ios::app    | Отваря за вмъкване без да изтрива съдържанието на файла. Вмъква се винаги в края на файла.										 | 1  |
| ios::ate    | Отваря за вмъкване и установява указателя put в края на файла. Позволява и вмъкване на произволни места.						 | 2  |
| ios::binary | Превключва режима от текстов в двоичен.                                                                                          | 4  |
| ios::in     | Отваря файл за извличане.                                                                                                        | 8  |
| ios::out    | Отваряне на файл за вмъкване. Допуска се вмъкване на произволни места във файла. Ако файлът съществува, съдържанието се изтрива. | 16 |
| ios::trunc  | Ако файлът съществува, съдържанието се изтрива.                                                                                  | 32 |

```c++
ofstream file("file.txt", ios::out | ios::app);
```

<h3>Флагове на състоянията на потока</h3>

| Флаг:  | Значение:                                                                    | 
|--------|------------------------------------------------------------------------------|
|bad()   | Има загуба на информация. Някоя операция за четене и писане не е изпълнена.  |
|fail()  | Последната входно/изходна операция е невалидна.								|
|eof()   | Достигнат е края на файла. 													|
|good()  | Всички операции са изпълнени успешно.										|
|clear() | Изчиства състоянието на потока (Вече good() ще върне истина).				|

<h3>Двоични файлове</h3>

<h5>Използване на функциите:</h5>

1. .read(char* memoryBlock, size_t size);
2. .write(const char* memoryBlock, size_t size);

Обърнете внимание, че функцията приема **char\***. Ако искаме да запазим променлива от друг вид, ще трябва експлицитно да преобразуваме указателя към тип char* (без значение, че указателят не сочи към елементи от тип char)

<h5>Пример за писане в двоичен файл:</h5>

```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ofstream f("file.dat");

	int a = 155555;

	f.write((const char*)&a, sizeof(int));
}
```

<h5>Пример за четене от двоичен файл:</h5>

```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ifstream f("file.dat");

	int a;

	f.read((char*)&a, sizeof(int));

	std::cout << a << std::endl;
}
```

<h5>Съдържанието на двоичния файл:</h5>

![enter image description here](https://i.ibb.co/G3R72qG/sudurjanie.png "Binary file example")
 
Байтовете се записват в **обратна посока**. Най-старшият байт е последен. Следователно запаметеното число е **00025fa3**, което е точно шестнадесетичния запис на числото **155555**.
 
<h5>Примери за запазване на структури във файл</h5>
 
- запазване на структура,която не използва динамична памет - **simple_struct_binary.cpp** и **student_staticName_to_binary.cpp**
- запазване на структура,която използва динамична памет - **students_dynamicName_to_binary.cpp**

<h5>Пример за запазване на масив от структури във файл</h5>
  
- запазване и четене на масив от обекти,които не използва динамична памет - **array_of_students_write.cpp**, **array_of_students_read.cpp** 

```c++
#include <iostream>
#include <fstream>

struct Test
{
	char ch;
	int a;
};

int main()
{
    std::ofstream f("output.dat", std::ios::binary);
    
    if(!f.is_open())
    {
        std::cout << "Error!" << std::endl;
        return -1;
    }
    
    Test arr[3] = {{'a', 400},{'b', 500},{'c', 600}};
    
    f.write((const char*)&arr, sizeof(arr));
    
    f.close();
}
```

След изпълнението на програмата, файлът (**output.dat**) изглежда така:

![Image of the binary file after running the code](https://i.ibb.co/0JthLd6/3-A978-D14-7-C7-A-4-ABD-8-B0-C-DA27-F6-E9-CD0-A.png "Binary file")

<h3>Примерни задачи</h3>

**Задача 1:** Напишете програма, която отпечатва собствения си код.

**Задача 2:** Напишете функция, която приема име на съществуващ файл и име на нов файл и копира съдържанието на съществуващия файл, в новия файл.

**Задача 3:** Да се напише функция, която намира големината на файл.

**Задача 4:** Да се напише функция, която заменя всяко срещане на символ във файл с друг символ. Съдържанието на файла не трябва да се зарежда в паметта.

<h3>Домашно</h3>

**Задача 1**: Напишете програма,  която чете comma-separated values (**CSV**) файл със студенти **със следните 4 полета**: Първо име, Фамилно име, Имейл, Факултетен номер.
1. Със стартирането на програмата потребителят да въвежда име на файл, който да бъде зареден в паметта.
2. Напишете функция, която след зареждане на файла да отпечатва на **стандартния изход** информация за студента при подаден **факултетен номер**.
3. Напишете функция, която **по подаден факултетен номер и низ**, променя email-a на студента, който има дадения факултетен номер, с подадения низ.
4. Напишете функцията , която приема низ (име на файл) и запазва студентите в същия формат (**CSV**). Т.е. при повторно пускане на програмата да може да прочете новия генериран файл.

Да се реализира прост интерфейс, с който да се извикват написаните функции през конзолата:

**Пример:**

```
Open file: 
>students.csv
File successfully opened!
>print 80000
Name = Stefan Velkov, Email: stefan@yahoo.com, FN: 80000
>edit 80000 stecho@abv.bg
>print 80000
Name = Krum Velkov, Email: stecho@abv.bg, FN: 80000
>save students2.csv
file students2.csv successfully saved!
```

**Задача 2**: Да се реализира програма за изглед и модификация на двоични файлове (hex viewer). При стартиране на програмата трябва да се въведе път до двоичен файл и да зареди съдържанието на файла в паметта. След като файлът се е заредил в паметта, трябва да поддържате следните операции:

- Преглед на файла (view)  отпечатва байтовете на файла (в шестнадесетична бройна система). След това да се отпечатат интерпретацията на байтовете като символи. Ако байтът отговаря на малка/голяма латинска буква, то да се отпечата символа. В противен случай да се отпечатва точка.
- Промяна на байт по индекс (change).
- Премахване на последния байт (remove).
- Добавяне на байт в края (add).
- Запазване на промените в същия файл (save).
- Запазване на промените в друг файл (save as).

Нека имаме двоичен файл, myData.dat, който се е получил след изпълнението на следния c++ код:

```c++
int x = 25409;
ofstream file(“myData.dat”, ios::binary);
file.write((const char*)&x, sizeof(x));
```

Да се реализира прост интерфейс, с който да се извикват написаните функции през конзолата.

**Важно** Не се позволява използването на stl, както и std::hex.