
<h1>Разделна компилация и работа с библиотеки</h1>

Една програма на С++ може да бъде разбита в множество файлове, които се **компилират независимо един от друг**, т.е. осъществява се **разделна компилация**. В резултат на компилацията се получават няколко **обектни файла** (файлове с разширение **.o**). Изпълнимият код на програмата (файл с разширение **.ехе**) се получава след свързване на обектните файлове (**Linking**).

<h3>Стъпки на компилиране</h3>

1. Preprocessing - Става с флагът **-E** на компилатора. Това разгъва всички препроцесорни директиви и ни дава финалният вид на нашия код.

2. Assembling - Става с флагът **-S** на компилатора. Това сглобява нашият код и създава assembler кода с инструкциите на нашият код.

3. Compilation - Става с флагът **-c** на компилатора. Това компилира assembler кода до машинен код.

4. Linking - Става чрез изреждане изреждане на object файловете и създаваме изпълним файл.


<h3>Заглавни файлове(Headers)</h3>

За да се възползваме максимално от разделната компилация, разделяме логиката на **.h** или **.hpp** за дефинициите и **.cpp** файлове за имплементациите. Навсякъде където ще работим с функционалността, ще включваме **само header файла**. По този начин, ако променим реализацията на някоя от функциите, ще се **прекомпилира само този файл**.

![enter image description here](https://i.ibb.co/N9RnMHv/sss.png)

<h3>Guards</h3>

Разделяйки кодът ни на отделни файлове се появява един проблем. Какво ако добавя кода повече от 1 път в друг файл?

```c++
// unguarded.hpp
void func(){}
```

```c++
// main.cpp
#include "unguarded.hpp"
#include "unguarded.hpp"

int main()
{
    func();
    return 0;
}
```

Получаваме следната грешка:

```
In file included from test.cpp:2:
unguarded.hpp:1:6: error: redefinition of 'void func()'
    1 | void func(){}
      |      ^~~~
In file included from test.cpp:1:
unguarded.hpp:1:6: note: 'void func()' previously defined here
    1 | void func(){}
      |      ^~~~
```

С други думи сме опитали да редефинираме функцията func. Което очевидно не е добре. Тук се появяват guard клаузите:

- Първият подход, който ще разгледаме са така наречените ifndef guard-ове.

```c++
// guarded.hpp
#ifndef __GUARDED_HPP
#define __GUARDED_HPP

void func(){}

#endif // __GUARDED_HPP
```

```c++
#include "guarded.hpp"
#include "guarded.hpp"

int main()
{
    func();
    return 0;
}
```

Тук програмата се компилира без проблем. Това се случва защото сме сложили защита за редефиниране на функцията. Проблемът на **#ifndef** guard-а, е че разчита на това всеки header да има уникален идентификатор в примера **__GUARDED_HPP**. Проблемът на това, е че не винаги това е гарантирано и потенциално може да се счупи.

- Вторият подход, който ще разгледаме е препроцесорната директива **#pragma once**.

```c++
// guarded.hpp
#pragma once

void func(){}
```

```c++
#include "guarded.hpp"
#include "guarded.hpp"

int main()
{
    func();
    return 0;
}
```

Директивата **#pragma once** следи за това файлът с това име да се добавя само веднъж при компилация. С други думи прави същото като **#ifndef** guard-а, само че по-ефективно. Единственият проблем на тази клауза, е че е compiler specific. Това означава, че ако пишете съвместим код, който трябва да върви на всякакви платформи и трябва да може да бъде компилиран от други компилатори, това не е добра опция и е по-добре да се използва **#ifndef**.

<h3>Библиотеки</h3>

След като разбрахме, какво е разделна компилация и още какви опции има компилатора, е време да покажем и един от най-често използваните механизми на езиците, които се компилират, за лесно дистрибутиране на код. А именно това са библиотеките. Библиотеките са полезни, защото ви позволяват да дадете достъп достъп до вашия код без да споделяте реалната имплементация(.cpp файловете).

Има два вида **statically linked library** и **dynamically linked library** или за по-кратко **sll** и **dll**. Разликата между двете е следната:

- **sll** библиотеките трябва да бъдат добавени по време на компилация. Те стават част от финалният изпълним файл. Всяка библиотека трябва да започва с **lib**, за да бъде разпозната като такава.

- **dll** библиотеките трябва да бъдат в указаният по време на компилация път. Те не са част от финалният изпълним файл, затова той ги търси по време на изпълнение, за да намери инструкциите, които трябва да се изпълнят.

<h5>Как се създава sll библиотека</h5>

Компилационен процес:

```
g++ -c impl.cpp -o mylib.o - създаваме object файлът за нашата имплементация.

ar rcs libmylib.a mylib.o - създаваме библиотеката като използваме архиватора ar.

g++ main.cpp -o main.exe -L. -lmylib - създаваме крайният изпълним файл.
```

- Опцията -c само компилира и сглобява файла, но не го свързва.
- Опциите rcs за архиватора ar правят следното:
    - r - Вмъква файлове в архива, ако те все още не съществуват в него, ако съществуват ги презаписва.
    - c - Създава архива(библиотеката), ако тя все още не съществува, ако съществува не прави нищо.
    - s - Създава символна таблица в архива за по-бързо търсене в него.
- Опцията -L указва какъв е пътя, в който се намира нашата библиотека("." означава текущата директория).
- Опцията -l указва как е името на библиотеката(тук не се слага lib предиката).

Така успешно сме направили статична библиотека, която можем да разпространим заедно с нашите header-и.

<h5>Как се създава dll библиотека</h5>

Компилационен процес:

```
g++ -c impl.cpp -o mylib.o - създаваме object файлът за нашата имплементация.

g++ -shared -o mylib.dll mylib.o -Wl,--out-implib,libmylib.a - създаваме споделената динамична библиотека.

g++ main.cpp -o main.exe -LLibrary -lmylib - създаваме крайният изпълним файл.
```

- Опцията -shared указва на компилатора, че това ще е динамично свързана библиотека.
- Опцията -Wl казва, че следващите аргументи разделени със запетая, ще бъдат пренасочени към linker-а.
    - Опцията --out-implib създава библиотека за import на име libmylib.a.
След компилация на крайният изпълним файл, трябва да сложим .dll библиотеката в същата директория като него, за да може да се изпълни.

<h3>Домашно</h3>

**Задача 1:** Създайте статична и динамична библиотека, в която да има следните функционалности:

- Да се създаде структура човек. Той ще съдържа име(динамично заделен низ), години и пол(Man/Woman/Unknown).
- Да се създадат функции за инициализиране и изтриване на човек.
- Да се създаде функция за говорене, с един параметър символен низ(който ще се "изговори").
- Да се създаде функция за принтиране на информацията на човек.

Всичката функционалност трябва да се намира в namespace Person.

**Задача 2:** Харесайте си библиотека от интернет и се опитайте да подкарате примерна програма, която я използва.