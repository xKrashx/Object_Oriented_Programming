<h1>Жизнен цикъл на обект. Конструктори и деструктори. Изключения.</h3>

<h3>Жизнен цикъл на обект:</h3>

- Създаване на обект в даден scope – заделя се памет и полетата се инициализират.
- Достига се до края на скоупа(област).
- Обектът се изтрива и паметта, която е асоциирана с него, се освобождава.

<h3>Конструктор:</h3>

- Извиква се веднъж - при създаването на обекта.
- Не се оказва експлицитно тип на връщане.
- Има същото име като класа.
 
<h3>Деструктор:</h3>

- Извиква се веднъж - при изтриването на обекта.
- Не се оказва експлицитно тип на връщане.
- Има същото име като класа със символа '~' в началото.

<h5>Пример за реализация на конструктор и деструктор на клас</h5>

```c++
#include <iostream>

struct Test 
{
    Test()
    {
        std::cout << "Object is created" << std::endl;
    }

    ~Test()
    {
        std::cout << "Object is destroyed" << std::endl;
    }

    int a;
    int b;
};

int main()
{
	while ()
	{
		Test t;// Object is created 
		if ()
		{
			Test t2; // Object is created 

		}// Object is destroyed (t2)

	}//Object is destroyed (t)
}
```
 
<h5>Конструктори и деструктор при влагане на обекти</h5>
 
```c++
#include <iostream>
#include <iomanip>

struct A
{
    A()
    {
        std::cout << "Constructor(default) of A" << std::endl;
    }

    ~A()
    {
        std::cout << "Destructor of A" << std::endl;
    }
};

struct B
{
    B()
    {
        std::cout << "Constructor(default) of B" << std::endl;
    }

    ~B()
    {
        std::cout << "Destructor of B" << std::endl;
    }
};

struct C
{
    C()
    {
        std::cout << "Constructor(default) of C" << std::endl;
    }

    ~C()
    {
        std::cout << "Destructor of C" << std::endl;
    }
};

struct X
{
    A first;
    B second;
    C obejectsArray[3];

    X()
    { //calls Constructor(default) of A, Constructor(default) of B, Constructor(default) of C" (x3)
        std::cout << "Constructor of X" << std::endl;
    }

    ~X()
    {
        std::cout << "Destructor of X" << std::endl;
    } //calls Destructor of C" (x3) , Destructor of B, Destructor of A
};

int main()
{
	X  obj; //Constructor of X
} // Destructor of X
```

<h3>Конструктор и деструктор при обекти с динамична памет</h3>

```c++
#include <iostream>

struct Test 
{
    Test()
    {
        std::cout << "Object is created" << std::endl;
        name = new char[10]; // Заделяме паметта при създаване на обекта.
    }

    ~Test()
    {
        std::cout << "Object is destroyed" << std::endl;
        delete[] name; // Изчистваме паметта, когато обектът "умре".
    }

    int a;
    char *name;
};

int main()
{
	while ()
	{
		Test t;// Object is created 
		if ()
		{
			Test t2; // Object is created 

		}// Object is destroyed (t2)

	}//Object is destroyed (t)
}
```

<h3>Default constructor vs param constructors</h3>

Когато нямаме дефиниран нито един конструктор, компилатора сам създава конструктор по подразбиране. Когато имаме дефиниран поне един конструктор (независимо с параметри или не) компилаторът спира да създава конструктор по подразбиране сам и трябва да използваме вече дефинираните от нас.

```c++
struct S
{
    int n;
    S();
    S(int);
};

S::S()
{
    n = 0;      // S::n бива занулен.
}

S::S(int n)
{
    this->n = n; // S::n взима стойността на параметъра n.
}

int main()
{
    S s;        // Извиква S::S()
    S s2(10);   // Извиква S::S(int)
}
```

<h3>Инициализиращ списък</h3>

Или още инициализиращ списък е специална синтактична форма за инициализиране на не-дефолтните променливи на класа. Синтактично представлява двоеточие (`:`), последвано от списък разделен със запетайки (`,`) от изброени `member-initializers`.
Всеки `member-initializer` има един от следните синтаксиси:


```c++
struct S
{
    int n;
    S(int);       // Декларация на параметризиран конструктор
    S() : n(7) {} // Дефиниция на конструктор по подразбиране:
                    // ": n(7)" инициализиращ списък.
};

S::S(int x) : n{x} {} // Дефиниция на параметризиран конструктор: ": n{x}" инициализиращ списък

int main()
{
    S s;      // Извиква S::S()
    S s2(10); // Извиква S::S(int)
}
```

Ако не статично поле има инициализираща стойност по подразбиране и се появява в инициализиращият списък, тогава стойността по подразбиране се игнорира и стойността от инициализиращият списък се използва:

```c++
struct S
{
    int n = 42;   // Инициализираща стойност по подразбиране.
    S() : n(7) {} // Задава стойността на n да е 7.
};
```

Членове референции не мога да бъдат обвързани с временни обекти, в инициализиращият списък:

```c++
struct A
{
    A() : v(42) {} // Error
    int& v;
};
```

***!!!Променливите се инициализират в реда на тяхната декларация, независимо от реда им на изброяване в инициализиращия списък!!!***

```c++
struct Foo
{
    int i;
    double d;
    float f;

    Foo(): f{4.2}, d{3,14}, i{69} {} // i will be initialized first, after that d and lastly f
};
```

<h3>Изключения</h3>

Ключовата дума `throw` прекратява изпълнението на текущата функция/метод и започва процеса по разгъване на стека. Докато прави така нареченият *"Stack unwinding"* програмата извиква деструкторите на всички обекти в стековата рамка на функцията, в която се намира. Този процес продължава, докато грешката не бъде хваната или докато не терминира main функцията, с което и програмата.

```c++
int main()
{
    throw 20; // terminate called after throwing an instance of 'int'
}
```

**!!!Важно!!!**

1. При разгъване на стековата рамка може да се пренася само по 1 грешка в даден момент от време. Ако станат повече от 1 програмата директно се терминира, дори и обработваме грешките, някъде по-надолу в стека.

2. Никога не хвърляме грешка в деструктора на някой клас!!!
    - Хвърляйки грешка в деструктора на някой обект може да се появи следната ситуация:
        main -> f -> g.
        В f сме създали обект от тип T и той хвърля грешка от тип int в деструктора си.
        g хвърля грешка от тип char.
        В процеса на разгъване на стека g бива терминирана, след което и f, но f извиква деструктора на обекта от тип T, с което стават две различни грешки, които трябва да бъдат предадени и обработени.
        Програмата обаче не може да се ориентира, коя грешка е по-важна, с което прекратява нашата програма.

3. Ако хвърлим грешка в конструктора, на някой обект, то този обект няма да бъде създаден изобщо, но е хубаво преди да я хвърлим да освободим динамичната памет, която сме заделили.

<h3>try & catch</h3>

- В try блока пишем код който потенциално може да хвърли грешка.
- В catch блока хващаме грешките хвърлени от try блока и ги обработваме.

Можем да слагаме няколко catch блока един след друг с различни параметри.
Като накрая можем да сложим блокът `catch(...)`, който хваща всички останали изключения.

```c++
#include <iostream>

int main(){
    try
    {
        throw 20;
    }
    catch(int e)
    {
        std::cout << "Exception occurred exception code: " << e << '\n';
    }
    catch(char const *c)
    {
        std::cout << "Exception occurred: " << e << '\n';
    }
	catch(...)
	{
        std::cout << "Exception occurred!\n";
	}
}
```

<h3>Видове грешки</h3>

Стандартната библиотека за грешки `exception`. В нея има различни видове грешки, които можете да разгледате [тук](https://en.cppreference.com/w/cpp/error/exception).

```c++
#include <iostream>
#include <exception>

int main()
{
    try
    {
        throw std::invalid_argument("Exception occurred");
    }
    catch(const std::invalid_argument &e)
    {
        std::cerr << e.what() << '\n';
    }
}
```

<h3>Примерни задачи</h3>

**Задача 1:** Да се направи клас Athlete(атлет), в който да има следните полета и методи:

- Полета
    - Име: низ
    - Стамина: цяло положително число в интервалът [1, 5]
    - Бързина: цяло положително число в интервалът [1, 5]
    - Сила: цяло положително число в интервалът [1, 5]
    - Травма: булева стойност
    - Отбор: низ
    - Спорт: едно от: Football, Basketball, Volleyball, Tens

- Методи
    - Конструктор по подразбиране
    - Параметричен конструктор
    - Деструктор
    - Get методи за полетата
    - Метод за смяна на отбор
    - Метод за трениране (ако атлетът няма травма)
    - Метод за принтиране на информацията

<h3>Домашно</h3>

**Задача 1:** Да се създаде клас String, който да реализира следните функционалности:

- Конструктор по подразбиране, който заделя място за низ с до 16 символа.
- Параметризиран конструктор, на който да му се подава капацитет на низа.
- Параметризиран конструктор, на който да му се подава символен низ, който да се копира.
- Метод Copy, който копира подаден като аргумент символен низ.
- Метод Append, който залепя за края на символния низ нов, който е подаден като аргумент.
- Метод Combine, който обединява текущия низ с такъв, който е подаден като аргумент и връща нов низ като резултат.
- Метод c_str, който да връща указателят на низа като константен.
- Метод Length, който връща дължината на низа.
- Метод Clear, който изчиства съдържанието на низа.
- Метод Empty, който да казва дали низът е празен.
- Метод At, който връща символ на позиция i, която е подадена като аргумент.

**Задача 2:** Създайте клас Beer, който има две полета - *марка*(максимална дължина 128 символа) и количество в милилитри. Напишете *параметризиран конструктор*. Също така да се следват принципите на капсулацията. Да се реализират следните функционалности на класа:

- Напишете get методи за марката и количеството на бирата.
- Напишете метод, който добавя една бира към друга.
- Напишете метод, който допълва бирата с дадени милилитри.
- Напишете метод, който проверява дали дадена бира съдържа каквото и да е количество от дадена марка.

Пример за работа:

beer1 - Corona, 500ml
beer2 - Heineken, 500ml

beer1.add(beer2, 250);

beer1 - Corona&Heineken, 750ml
beer2 - Heineken, 250ml

beer1.check("Heineken") - true
beer1.check("Stella Artois") - false
beer1.check(beer2.getName()) - true

**Задача 3:** Да се реализира клас, който представя сума на масив от числа по следният начин: 3^0 + 7^1 + 2^3 + ... k^(n-1). Да се създадат два конструктора, един по подразбиране, който да слага големината на масива на 10 и един параметричен, на който ще се подава колко елемента искаме да е масива.

Пример за работа:

sumator.add(4);
sumator.add(2);

sumator.getSum(); - 3

sumator.add(5);

sumator.getSum(); - 28

sumator.removeLast();

sumator.getSum(); - 3

sumator.changeAt(5, 1);

sumator.getSum(); - 6

**Задача 4:** Реализирайте клас **Time**, който ще се използва за работа с часове (13:05:45). Вашият клас трябва да има следния интерфейс:

- Подразбиращ се конструктор, който създава часа на **00:00:00**.
- Конструктор, който приема три параметъра - **час, минути и секунди**.
- Член-функция, която връща оставащото време до **полунощ**.
- Член-функция, която увеличава часа с 1 секунда.
- Член-функция, която връща дали е **време за вечеря**. В рамките на задачата време за вечеря е между **20:30** и **22:00**.
- Член-функция, която връща дали е **време за парти**. В рамките на задачата време за парти е между **23:00** и **06:00**.
- Член-функция, която приема друг обект от тип **Time** и връща обект от тип **Time**, което е разликата между двете времена. 
- Член-функция, която която приема друг обект от тип **Time** и сравнява двата обекта (по-къснен/по-ранен).
- Член-функция за принтиране на часа.

Да се направи масив от 10 времена и да се сортира стабилно с някоя от изучаваните сортировки.
**Бонус:** Да се обоснове, коя е най-добрата сортировка за тази задача и защо.

**Задача 5:** Реализирайте клас интервал, който представлява интервал [a,b]  (задължително а <= b) от реалната права. Нашият интервал ще бъде дискретен - началото и краят му ще бъдат цели числа и ще разглеждаме само точки, които са цели числа. Реализирайте следният интерфейс:

- Подразбиращ се конструктор, който създава интервала **[0,0]**.
- Конструктор, който приема двата параметъра. Ако a<=b, то създава интервала **[a,b]**. В противен случай, създава **[0,0]**.
- get и set функции. **Във всеки един момент данните в интервала трябва да са валидни!** Помислете каква валидация нужна в set-ърите.
- Член-функция, която връща **дължината на интервала**.
- Член-функция, която приема число и проверява **дали е част от интервала**.
- Член-функция, която връща **броя на простите числа** в интервала.
- Член-функция, която връща **броя на числата в интервала**, които са палиндроми.
- Член-функция, която връща **броя на числата, които нямат повтарящи цифри**.

За предните 3 функции, можете да направите една функция, която приема предикат. Тогава другите 3 функции ви стават частен случай на тази.

- Член-функция, която връща дали началото и края на интервала са **степени на 2-ката**. ([2,16] - истина) 
- Член-функция, която приема интервал и връща **сечението на текущия интервал с подадения**.  (Сечението на [1, 5]  [3, 7]  e [3, 5]).
- Член-функция, която приема интервал и връща **обединението на текущия интервал с подадения**. (Обединението на [1, 5]  [3, 7]  e [1, 7]). Обединението е дефинирано, ако двата интервала се пресичат. Ако не е дефинирано, то функцията да връща **[0,0]**.
- Член-функция, която приема интервал и връща дали подадения (като параметър) интервал е **под интервал на текущия**(обектът, от който се извиква функцията).

**Пример за работа с класа:**
```c++
int main()
{
     Interval t1(3,10); // [3, 10]
     Interval t2(4,14); // [4, 14]
     Interval t3; // [0, 0]

     Interval result = t1.intersect(t2); // [4, 10]
     
     t2.isSuperInterval(result); //true
     
     result.countOfPrimeNumbers() // 2 (only 5 and 7)
}
```