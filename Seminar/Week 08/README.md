<h1>Предефиниране на оператори. Класове с масиви от указатели към обекти. Умни указатели.</h1>

<h3>Oператори</h3>

<h5>Видове оператори:</h5>
в C++ има три вида оператори:

- Унарни (на един аргумент)
- Бинарни (на два аргумента)
- Тернарен (на три аргумента)

<h5>Операторите се характеризират с:</h5>

- Приоритет
- Асоциативност
- Позиция на оператора спрямо аргумента - *префиксен*, *инфиксен* и *суфиксен*

<h5>Списъка на операторите в C++:</h5>

| Оператор                                       | Асоциативност                   |
|------------------------------------------------|---------------------------------|
| () [] -> . ++ --                               |      лявоасоциативен       	   |
|  + - ! ~ ++ -- (type)* & sizeof                |      дясноасоциативен      	   |
| * / %                                          |		лявоасоциативен     	   |
|  + -        									 |      лявоасоциативен			   |
|    << >>      								 |      лявоасоциативен			   |
|  <  <=  >  >=         						 |      лявоасоциативен			   |
|    ==  !=       								 |      лявоасоциативен			   |
|      &     									 |     	лявоасоциативен			   |
|     ^      									 |     	лявоасоциативен			   |
|      \|     									 |      лявоасоциативен			   |
|       &&    									 |      лявоасоциативен			   |
|      \|\|     								 |      лявоасоциативен			   |
|      ?:    									 |      дясноасоциативен           |
|     =  +=  -=  *=  /=  %=  >>=  <<=  &=  ^=    |      дясноасоциативен           |

<h5>Рестрикции:</h5>

- Операторите: :: (scope resolution), . (member access), .* (member access through pointer to member), ?: (ternary conditional), sizeof (size of object) и typeid (type id of object) не могат да се предефинират.
- Нови оператори като: **, <>, или &|, не могат да бъдат създадени.
- Не е възможно да се променят приоритета, групирането или броя на операндите на операторите.
- Предефинирането на оператора -> трябва или да върне обикновен указател, или да върне обект (по референция или по стойност), за който операторът -> на свой ред е предефиниран.

<h3>Пример за предефиниране на оператор:</h3>

```c++
Complex& Complex::operator+=(const Complex& other)
{
	real += other.real;
	im += other.im;
	return *this;
}
```

<h5>Вече може да правим следното:</h5>

```c++
int main()
{
	Complex c(1,3); //1 + 3i;
	Complex c2(10,20) // 10 + 2i;
	c += c2 // now c is 11 + 5i
}
```

<h3>Оператори за вход и изход</h3>

Предефинирането на **operator>>** и **operator<<**, които респективно взимат обекти от тип **std::istream&** и **std::ostream&** като лявостоящи аргументи, се наричат оператор за извличане и оператор за вмъкване. Тъй като те взимат потребителски дефиниран тип, като десен аргумент, те **трябва** да се имплементират, като външни/приятелски функции.

```c++
std::ostream& operator<<(std::ostream& os, const T& obj)
{
    // write obj to stream
    return os;
}

std::istream& operator>>(std::istream& is, T& obj)
{
    // read obj from stream
    if( /* T could not be constructed */ )
        is.setstate(std::ios::failbit);
    return is;
}
```

<h3>Масиви от указатели към обекти</h3>

До момента сме свикнали да създаваме масиви от обекти, което изглежда така:

![](https://i.ibb.co/GCvzWBS/R7q3g.png)

Тук обаче има няколко проблема с колекцията:

1. Бавно разместване на елементи
2. Нямаме възможност за празни клетки
3. Задължително ни трябва конструктор по подразбиране

Решението на тези проблеми е колекция, която държи указатели към обектите, вместо самите обекти. Това изглежда по следният начин:

```c++
class SomeCollection
{
    A** data;
    //other things
};
```

![enter image description here](https://i.ibb.co/NYqr8k2/XtIzL.png)

<h5>Какви са ползите:</h5>

- Бързо разместване на обектите в колекцията - не се изисква да се копират. Само разместваме указателите
- Не се изисква съществуването на конструктор по подразбиране на A.
- Възможно е да имаме "празна клетка", като се възползваме от възможната nullptr стойност.

<h3>Домашно</h3>

**Задача 1:** Реализирайте клас **Nvector**, който ще се използва за работа с математически вектор. Предефинирайте оператори със следната функционалност:

- Събиране на вектори.
- Изваждане на вектори.
- Умножение на вектор със скалар.
- Проверка дали два вектора са успоредни.
- Проверка дали два вектора са перпендикулярни.
- Взимане на дължина на вектор.
- Достъп до произволен елемент на вектор.
- Вход и изход от потоци.

```c++
int main()
{
	Nvector v(4);
	cin >> v;

	Nvector v2(4);
	cin >> v;

	Nvector result = v + v2;
	cout << result << endl;
}
```

Релизирайте клас двумерната декартова координатна система, която приема 2 вектора, които са нейният базис. Реализрайте следните функции:

- Връща вектор в базиса по подадени 2 координата.
- По подаден вектор връща координатите му в базиса.
 
```c++
int main()
{
	Nvector v(4);
	v[0] = 2;
	v[1] = 1;
	
	Nvector v2(4);
	v2[0] = 3;
	v2[1] = 1;
	
	twoDimCoordSystem s(v1, v2);
	
	cout << s1.getVectorByCoordinates(7, 4); // [26, 11]

	cout << s1.getCoordinatesByVector(7, 4); // [5, -1]

	cout << result << endl;
}
```
 
**Задача 2:** Реализирайте клас **ComplexNumber**, който ще се използва за работа с комплексни числа. Предефинирайте оператори със следната функционалност:

- Събиране на комплексни числа.
- Изваждане на комплексни числа.
- Умножение на комплексни числа.
- Деление на комплексни числа.
- Вход и изход от потоци.

```c++
int main()
{
	ComplexNumber c;
	cin >> c;

	ComplexNumber c2;
	cin >> c2;

	ComplexNumber result = c2 / c;

	cout << result << endl;
}
```